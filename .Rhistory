tmp=read.csv('fake data8.csv',as.is=T)
ind=which(colnames(tmp)=='X')
dat=tmp[,-ind]
nloc=nrow(dat)
#basic settings
gamma1=0.1
ncomm=10
ngibbs=1000
phi.prior=0.1
nburn=ngibbs/2
mu0=2#1.33
sd0=sqrt(1)#sqrt(0.1) (very bad: finds 4 groups), sqrt(1) (almost good: finds 6 groups),sqrt(3.72)
#fit model
res=lda.abundance.regression(dat=dat,ncomm=ncomm,phi.prior=phi.prior,gamma1=gamma1,ngibbs=ngibbs,sd0=sd0,mu0=mu0,nburn=nburn)
tmp=res$theta[nrow(res$theta),]
theta=matrix(tmp,nloc,ncomm)
boxplot(theta)
plot(NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncomm){
lines(1:nloc,theta[,i],col=i)
}
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(4)
nloc=5000
nspp=100
ncommun=8
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=rdirichlet(ncommun,alpha=rep(0.1,nspp))
for (i in 1:nspp){
ind=sample(1:ncommun,size=ncommun/2)
tmp[ind,i]=0
}
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
image(phi)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(4)
nloc=5000
nspp=100
ncommun=8
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=rdirichlet(ncommun,alpha=rep(1,nspp))
for (i in 1:nspp){
ind=sample(1:ncommun,size=ncommun/2)
tmp[ind,i]=0
}
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(5)
nloc=5000
nspp=100
ncommun=8
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=rdirichlet(ncommun,alpha=rep(1,nspp))
for (i in 1:nspp){
ind=sample(1:ncommun,size=ncommun/2)
tmp[ind,i]=0
}
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
nl=floor(runif(nloc,min=200,max=400))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,nspp)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\independent studies\\LDA explorations')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\independent studies\\LDA explorations')
source('gibbs functions.R')
source('gibbs sampler main function.R')
sourceCpp('aux1.cpp')
#get data
tmp=read.csv('fake data8.csv',as.is=T)
ind=which(colnames(tmp)=='X')
dat=tmp[,-ind]
nloc=nrow(dat)
#basic settings
gamma1=0.1
ncomm=10
ngibbs=1000
phi.prior=0.1
nburn=ngibbs/2
mu0=2#1.33
sd0=sqrt(1)#sqrt(0.1) (very bad: finds 4 groups), sqrt(1) (almost good: finds 6 groups),sqrt(3.72)
#fit model
res=lda.abundance.regression(dat=dat,ncomm=ncomm,phi.prior=phi.prior,gamma1=gamma1,ngibbs=ngibbs,sd0=sd0,mu0=mu0,nburn=nburn)
tmp=res$theta[nrow(res$theta),]
theta=matrix(tmp,nloc,ncomm)
boxplot(theta)
plot(NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncomm){
lines(1:nloc,theta[,i],col=i)
}
tmp=res$psi[nrow(res$psi),]
psi=matrix(tmp,nloc,ncomm-1)
boxplot(psi)
abline(h=mu0,col='red')
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\independent studies\\LDA explorations')
source('gibbs functions.R')
source('gibbs sampler main function.R')
sourceCpp('aux1.cpp')
#get data
tmp=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(tmp)=='X')
dat=tmp[,-ind]
nloc=nrow(dat)
#basic settings
gamma1=0.1
ncomm=10
ngibbs=1000
phi.prior=0.1
nburn=ngibbs/2
mu0=2#1.33
sd0=sqrt(1)#sqrt(0.1) (very bad: finds 4 groups), sqrt(1) (almost good: finds 6 groups),sqrt(3.72)
#fit model
res=lda.abundance.regression(dat=dat,ncomm=ncomm,phi.prior=phi.prior,gamma1=gamma1,ngibbs=ngibbs,sd0=sd0,mu0=mu0,nburn=nburn)
tmp=res$theta[nrow(res$theta),]
theta=matrix(tmp,nloc,ncomm)
boxplot(theta)
plot(NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncomm){
lines(1:nloc,theta[,i],col=i)
}
setwd('U:\\GIT_models\\git_LDA_MS')
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(5)
nloc=5000
nspp=100
ncommun=8
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
tmp=rdirichlet(ncommun,alpha=rep(1,nspp))
for (i in 1:nspp){
ind=sample(1:ncommun,size=ncommun/2)
tmp[ind,i]=0
}
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
nl=floor(runif(nloc,min=200,max=400))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,nspp)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_MS')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome)
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs functions.R')
source('gibbs sampler main function.R')
sourceCpp('aux1.cpp')
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs functions.R')
source('gibbs sampler main function.R')
sourceCpp('aux1.cpp')
tmp=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(tmp)=='X')
dat=tmp[,-ind]
nloc=nrow(dat)
#basic settings
gamma1=0.1
ncomm=10
ngibbs=1000
phi.prior=0.1
nburn=ngibbs/2
mu0=2#1.33
sd0=sqrt(1)#sqrt(0.1) (very bad: finds 4 groups), sqrt(1) (almost good: finds 6 groups),sqrt(3.72)
#fit model
res=lda.abundance.regression(dat=dat,ncomm=ncomm,phi.prior=phi.prior,gamma1=gamma1,ngibbs=ngibbs,sd0=sd0,mu0=mu0,nburn=nburn)
tmp=res$theta[nrow(res$theta),]
theta=matrix(tmp,nloc,ncomm)
boxplot(theta)
plot(NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncomm){
lines(1:nloc,theta[,i],col=i)
}
rm(list=ls(all=TRUE))
library('Rcpp')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs functions.R')
source('gibbs sampler main function.R')
sourceCpp('aux1.cpp')
#get data
tmp=read.csv('fake data8.csv',as.is=T)
ind=which(colnames(tmp)=='X')
dat=tmp[,-ind]
nloc=nrow(dat)
#basic settings
gamma1=0.1
ncomm=10
ngibbs=1000
phi.prior=0.1
nburn=ngibbs/2
mu0=2#1.33
sd0=sqrt(1)#sqrt(0.1) (very bad: finds 4 groups), sqrt(1) (almost good: finds 6 groups),sqrt(3.72)
#fit model
res=lda.abundance.regression(dat=dat,ncomm=ncomm,phi.prior=phi.prior,gamma1=gamma1,ngibbs=ngibbs,sd0=sd0,mu0=mu0,nburn=nburn)
tmp=res$theta[nrow(res$theta),]
theta=matrix(tmp,nloc,ncomm)
boxplot(theta)
plot(NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncomm){
lines(1:nloc,theta[,i],col=i)
}
get.w=function(nlk,psi,ncomm,nloc){
soma=matrix(NA,nloc,ncomm-1)
ge=ngreater(nlk=nlk,nloc=nloc,ncommun=ncomm) #greater or equal
pnorm1=pnorm(0,mean=psi,sd=1)
soma=getw(ge=ge, psi=psi, pnorm1=pnorm1,nlk=nlk,nloc=nloc,ncomm=ncomm)
# for (i in 1:nloc){
#   for (k in 1:(ncomm-1)){
#     #for zil>k
#     gt.k=ge[i,k+1]
#     w.gt.k=tnorm.neg(n=gt.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#
#     #for zil=k
#     eq.k=nlk[i,k]
#     w.eq.k=tnorm.pos(n=eq.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#
#     #summarize
#     soma[i,k]=sum(c(w.gt.k,w.eq.k))
#   }
# }
list(soma=soma,nge=ge)
}
get.w1=function(nlk,psi,ncomm,nloc){
soma=matrix(NA,nloc,ncomm-1)
ge=ngreater(nlk=nlk,nloc=nloc,ncommun=ncomm) #greater or equal
pnorm1=pnorm(0,mean=psi,sd=1)
for (i in 1:nloc){
for (k in 1:(ncomm-1)){
#for zil>k
gt.k=ge[i,k+1]
w.gt.k=tnorm.neg(n=gt.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#for zil=k
eq.k=nlk[i,k]
w.eq.k=tnorm.pos(n=eq.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#summarize
soma[i,k]=sum(c(w.gt.k,w.eq.k))
}
}
list(soma=soma,nge=ge)
}
tnorm.pos <- function(n,mu,sig,pnorm1){   #generates truncated normal variates based on cumulative normal distribution
z <- runif(n,pnorm1,1)
qnorm(z,mu,sig)
}
tnorm.neg <- function(n,mu,sig,pnorm1){   #generates truncated normal variates based on cumulative normal distribution
z <- runif(n,0,pnorm1)
qnorm(z,mu,sig)
}
set.seed(1)
rcpp.res=get.w(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
#useful stuff
y=data.matrix(dat)
nloc=nrow(y)
nspp=ncol(y)
hi=0.999999
lo=0.000001
#initial values
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
psi=matrix(0,nloc,ncomm-1)
#to store outcomes from gibbs sampler
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
psi.out=matrix(NA,ngibbs,nloc*(ncomm-1))
llk=rep(NA,ngibbs)
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
nks=tmp$nks
#get w
tmp=get.w(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
soma=tmp$soma
nge=tmp$nge
#get psi
psi=get.psi(soma=soma,nge=nge,sd0=sd0,mu0=mu0,ncomm=ncomm)
v=pnorm(psi) #calculate implied theta
theta=convertVtoTheta(vmat=cbind(v,1),prod=rep(1,nloc))
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
psi.out[i,]=psi
}
get.w=function(nlk,psi,ncomm,nloc){
soma=matrix(NA,nloc,ncomm-1)
ge=ngreater(nlk=nlk,nloc=nloc,ncommun=ncomm) #greater or equal
pnorm1=pnorm(0,mean=psi,sd=1)
soma=getw(ge=ge, psi=psi, pnorm1=pnorm1,nlk=nlk,nloc=nloc,ncomm=ncomm)
# for (i in 1:nloc){
#   for (k in 1:(ncomm-1)){
#     #for zil>k
#     gt.k=ge[i,k+1]
#     w.gt.k=tnorm.neg(n=gt.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#
#     #for zil=k
#     eq.k=nlk[i,k]
#     w.eq.k=tnorm.pos(n=eq.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#
#     #summarize
#     soma[i,k]=sum(c(w.gt.k,w.eq.k))
#   }
# }
list(soma=soma,nge=ge)
}
get.w1=function(nlk,psi,ncomm,nloc){
soma=matrix(NA,nloc,ncomm-1)
ge=ngreater(nlk=nlk,nloc=nloc,ncommun=ncomm) #greater or equal
pnorm1=pnorm(0,mean=psi,sd=1)
for (i in 1:nloc){
for (k in 1:(ncomm-1)){
#for zil>k
gt.k=ge[i,k+1]
w.gt.k=tnorm.neg(n=gt.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#for zil=k
eq.k=nlk[i,k]
w.eq.k=tnorm.pos(n=eq.k,mu=psi[i,k],sig=1,pnorm1=pnorm1[i,k])
#summarize
soma[i,k]=sum(c(w.gt.k,w.eq.k))
}
}
list(soma=soma,nge=ge)
}
tnorm.pos <- function(n,mu,sig,pnorm1){   #generates truncated normal variates based on cumulative normal distribution
z <- runif(n,pnorm1,1)
qnorm(z,mu,sig)
}
tnorm.neg <- function(n,mu,sig,pnorm1){   #generates truncated normal variates based on cumulative normal distribution
z <- runif(n,0,pnorm1)
qnorm(z,mu,sig)
}
set.seed(1)
rcpp.res=get.w(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
set.seed(1)
r.res=get.w1(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
sum(rcpp.res!=r.res)
head(rcpp.res)
set.seed(1)
rcpp.res=get.w(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
set.seed(1)
r.res=get.w1(nlk=nlk,psi=psi,ncomm=ncomm,nloc=nloc)
sum(rcpp.res$soma!=r.res$soma)
head(rcpp.res)
head(r.res$soma)
head(rcpp.res$soma)
sum(round(rcpp.res$soma,4)!=round(r.res$soma,4))
