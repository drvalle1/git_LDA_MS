for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media=mu+x%*%betas
res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
}
rm(list=ls(all=TRUE))
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('aux1.cpp')
nloc=1000
nspp=100
ncommun=5
mu=3
sd1=0.5
sig2=sd1^2
#generate covariates
tmp=rnorm(nloc*(ncommun-1))
xmat=matrix(tmp,nloc,ncommun-1)
colnames(xmat)=paste('cov',1:(ncommun-1),sep='')
#generate betas
seq1=(1:(ncommun-1))^2
betas=diag(seq1,ncommun-1)
betas[betas==0]=-1
betas.true=betas
#generate deltas
tmp=rnorm(nloc*(ncommun-1),mean=mu+xmat%*%betas,sd=sd1)
delta=matrix(tmp,nloc,ncommun-1)
#generate thetas
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#what do thetas look like?
par(mfrow=c(2,2))
for (i in 1:ncol(xmat)) plot(xmat[,i],theta[,i],main=i)
#create true curves
par(mfrow=c(2,2))
rango=range(xmat)
nsim=1000
ncov.val=500
seq1=seq(from=rango[1],to=rango[2],length.out=ncov.val)
for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media=mu+x%*%betas
res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
}
rm(list=ls(all=TRUE))
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('aux1.cpp')
nloc=1000
nspp=100
ncommun=5
mu=3
sd1=0.5
sig2=sd1^2
#generate covariates
tmp=rnorm(nloc*(ncommun-1))
xmat=matrix(tmp,nloc,ncommun-1)
colnames(xmat)=paste('cov',1:(ncommun-1),sep='')
#generate betas
seq1=1:(ncommun-1)
betas=diag(seq1,ncommun-1)
betas[betas==0]=-1.5
betas.true=betas
#generate deltas
tmp=rnorm(nloc*(ncommun-1),mean=mu+xmat%*%betas,sd=sd1)
delta=matrix(tmp,nloc,ncommun-1)
#generate thetas
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#what do thetas look like?
par(mfrow=c(2,2))
for (i in 1:ncol(xmat)) plot(xmat[,i],theta[,i],main=i)
#create true curves
par(mfrow=c(2,2))
rango=range(xmat)
nsim=1000
ncov.val=500
seq1=seq(from=rango[1],to=rango[2],length.out=ncov.val)
for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media=mu+x%*%betas
res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
}
rm(list=ls(all=TRUE))
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('aux1.cpp')
nloc=1000
nspp=100
ncommun=5
mu=3
sd1=0.5
sig2=sd1^2
#generate covariates
tmp=rnorm(nloc*(ncommun-1))
xmat=matrix(tmp,nloc,ncommun-1)
colnames(xmat)=paste('cov',1:(ncommun-1),sep='')
#generate betas
seq1=1:(ncommun-1)
betas=diag(seq1,ncommun-1)
betas[betas==0]=-1.5
betas.true=betas
#generate deltas
tmp=rnorm(nloc*(ncommun-1),mean=mu+xmat%*%betas,sd=sd1)
delta=matrix(tmp,nloc,ncommun-1)
#generate thetas
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#create true curves
par(mfrow=c(2,2))
rango=range(xmat)
nsim=1000
ncov.val=500
seq1=seq(from=rango[1],to=rango[2],length.out=ncov.val)
for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media=mu+x%*%betas
res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
}
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=200))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_MS')
nome=paste(c('fake data','fake data cov'),ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome[1])
write.csv(xmat,nome[2],row.names=F)
rm(list=ls(all=TRUE))
library('Rcpp')
library('mvtnorm')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
nloc=nrow(y)
#get covariates
xmat=data.matrix(read.csv('fake data cov5.csv',as.is=T))
npar=ncol(xmat)
xtx=t(xmat)%*%xmat
tx=t(xmat)
#priors
mu=3#5
sd1=0.5#3.286
sig2=sd1^2
prec=(1/sig2)*xtx+diag(1,npar)
var.betas=solve(prec)
#useful stuff
ncomm=5
hi=0.999999
lo=0.000001
#initial values of parameters
betas=matrix(0,npar,ncomm-1)
theta=matrix(1/ncomm,nloc,ncomm)
delta=matrix(0,nloc,ncomm-1)
phi=matrix(1/nspp,ncomm,nspp)
gamma=0.1;
#MH stuff
accept1=list(delta=matrix(0,nloc,ncomm-1))
jump1=list(delta=matrix(0.3,nloc,ncomm-1))
accept.output=100
#gibbs details
ngibbs=1000
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
betas.out=matrix(NA,ngibbs,npar*(ncomm-1))
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.delta.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc,
delta=delta,sig2=sig2,mu=mu,jump=jump1$delta,
xmat=xmat,betas=betas)
delta=tmp$delta
theta=tmp$theta
accept1$delta=accept1$delta+tmp$accept
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
betas=get.betas(var.betas=var.betas,sig2=sig2,tx=tx,
delta=delta,mu=mu,npar=npar,ncomm=ncomm)
#adapt MH
if (i%%accept.output==0 & i<1000){
tmp=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
jump1=tmp$jump1
accept1=tmp$accept1
}
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
betas.out[i,]=betas
}
betas
rm(list=ls(all=TRUE))
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('aux1.cpp')
nloc=1000
nspp=100
ncommun=5
mu=3
sd1=0.5
sig2=sd1^2
#generate covariates
tmp=rnorm(nloc*(ncommun-1))
xmat=matrix(tmp,nloc,ncommun-1)
colnames(xmat)=paste('cov',1:(ncommun-1),sep='')
#generate betas
seq1=1:(ncommun-1)
betas=diag(seq1,ncommun-1)
betas[betas==0]=-1.5
betas.true=betas
#generate deltas
tmp=rnorm(nloc*(ncommun-1),mean=mu+xmat%*%betas,sd=sd1)
delta=matrix(tmp,nloc,ncommun-1)
#generate thetas
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#create true curves
par(mfrow=c(2,2))
rango=range(xmat)
nsim=1000
ncov.val=500
seq1=seq(from=rango[1],to=rango[2],length.out=ncov.val)
for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media=mu+x%*%betas
res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
}
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=200))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,ncommun)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_MS')
nome=paste(c('fake data','fake data cov'),ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome[1])
write.csv(xmat,nome[2],row.names=F)
library('Rcpp')
library('mvtnorm')
set.seed(4)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data5.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
nspp=ncol(y)
nloc=nrow(y)
#get covariates
xmat=data.matrix(read.csv('fake data cov5.csv',as.is=T))
npar=ncol(xmat)
xtx=t(xmat)%*%xmat
tx=t(xmat)
#priors
mu=3#5
sd1=0.5#3.286
sig2=sd1^2
prec=(1/sig2)*xtx+diag(1,npar)
var.betas=solve(prec)
#useful stuff
ncomm=5
hi=0.999999
lo=0.000001
#initial values of parameters
betas=matrix(0,npar,ncomm-1)
theta=matrix(1/ncomm,nloc,ncomm)
delta=matrix(0,nloc,ncomm-1)
phi=matrix(1/nspp,ncomm,nspp)
gamma=0.1;
#MH stuff
accept1=list(delta=matrix(0,nloc,ncomm-1))
jump1=list(delta=matrix(0.3,nloc,ncomm-1))
accept.output=100
#gibbs details
ngibbs=1000
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
betas.out=matrix(NA,ngibbs,npar*(ncomm-1))
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.delta.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc,
delta=delta,sig2=sig2,mu=mu,jump=jump1$delta,
xmat=xmat,betas=betas)
delta=tmp$delta
theta=tmp$theta
accept1$delta=accept1$delta+tmp$accept
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+1,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
betas=get.betas(var.betas=var.betas,sig2=sig2,tx=tx,
delta=delta,mu=mu,npar=npar,ncomm=ncomm)
#adapt MH
if (i%%accept.output==0 & i<1000){
tmp=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
jump1=tmp$jump1
accept1=tmp$accept1
}
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
betas.out[i,]=betas
}
betas
par(mfrow=c(2,2))
rango=range(xmat)
nsim=1000
ncov.val=500
seq1=seq(from=rango[1],to=rango[2],length.out=ncov.val)
for (i in 1:(ncommun-1)){
x=matrix(0,ncov.val,ncommun-1)
x[,i]=seq1
media.estim=mu+x%*%betas
media=mu+x%*%betas.true
res.estim=res=matrix(NA,ncov.val,nsim)
for (j in 1:nsim){
#true
tmp=rnorm(ncov.val*(ncommun-1),mean=media,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res[,j]=tmp[,i]
#estim
tmp=rnorm(ncov.val*(ncommun-1),mean=media.estim,sd=sd1)
delta=matrix(tmp,ncov.val,ncommun-1)
prob=1/(1+exp(-delta))
vmat=cbind(prob,1)
tmp=convertVtoTheta(vmat,rep(1,nloc))
res.estim[,j]=tmp[,i]
}
res1=apply(res,1,quantile,c(0.025,0.5,0.975))
res1.estim=apply(res.estim,1,quantile,c(0.025,0.5,0.975))
#true
plot(seq1,res1[2,],ylim=range(res1))
lines(seq1,res1[1,],lty=3)
lines(seq1,res1[3,],lty=3)
#estim
lines(seq1,res1.estim[2,],col='red')
lines(seq1,res1.estim[3,],lty=3,col='red')
lines(seq1,res1.estim[1,],lty=3,col='red')
}
library(shiny)
runApp('U:/R/shiny_tutorial')
library(DT)
