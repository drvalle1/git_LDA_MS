#unstructured LDA
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
res=LDA.abundance(y=y,ncomm=ncomm,gamma=gamma,
ngibbs=ngibbs,nburn=nburn,psi=psi)
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
set.seed(4)
#-----------------------------------------------------------
#*****Unstructured LDA*****
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
res=LDA.abundance(y=y,ncomm=ncomm,gamma=gamma,
ngibbs=ngibbs,nburn=nburn,psi=psi)
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
set.seed(4)
#-----------------------------------------------------------
#*****Unstructured LDA*****
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
res=LDA.abundance(y=y,ncomm=ncomm,gamma=gamma,
ngibbs=ngibbs,nburn=nburn,psi=psi)
head(res)
str(res)
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
library('MCMCpack')
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
#get data
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
i=1
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=sum(dbeta(vmat[,-ncomm],1,gamma,log=T))+sum(ddirichlet(phi,rep(psi,ncomm),log=T))
?ddirichlet
ddirichlet(phi,rep(psi,ncomm))
ddirichlet(phi,rep(psi,nspp))
log.p.betas=sum(dbeta(vmat[,-ncomm],1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
log.p.betas
log.p.phi
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#calculate log prior
log.p.betas=sum(dbeta(vmat[,-ncomm],1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=log.p.betas+log.p.phi
theta.out[i,]=theta
phi.out[i,]=phi
vmat.out[i,]=vmat
}
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
library('MCMCpack')
set.seed(4)
#-----------------------------------------------------------
#*****Unstructured LDA*****
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
res=LDA.abundance(y=y,ncomm=ncomm,gamma=gamma,
ngibbs=ngibbs,nburn=nburn,psi=psi)
str(res)
unique(res$log.prior)
psi
#get data
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#calculate log prior
log.p.betas=sum(dbeta(vmat[,-ncomm],1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
print(c(log.pbetas,log.p.phi))
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=log.p.betas+log.p.phi
theta.out[i,]=theta
phi.out[i,]=phi
vmat.out[i,]=vmat
}
#get data
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#calculate log prior
log.p.betas=sum(dbeta(vmat[,-ncomm],1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
print(c(log.p.betas,log.p.phi))
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=log.p.betas+log.p.phi
theta.out[i,]=theta
phi.out[i,]=phi
vmat.out[i,]=vmat
}
#get data
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#calculate log prior
vmat1=vmat[,-ncomm]
vmat1[vmat1>hi]=hi; vmat1[vmat1<lo]=lo
log.p.betas=sum(dbeta(vmat1,1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
print(c(log.p.betas,log.p.phi))
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=log.p.betas+log.p.phi
theta.out[i,]=theta
phi.out[i,]=phi
vmat.out[i,]=vmat
}
ngibbs=11
#get data
nspp=ncol(y)
nloc=nrow(y)
#useful stuff
hi=0.999999
lo=0.000001
#initial values of parameters
theta=matrix(1/ncomm,nloc,ncomm)
phi=matrix(1/nspp,ncomm,nspp)
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
vmat.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
llk=rep(NA,ngibbs)
log.prior=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#get parameters
tmp=get.theta(nlk=nlk,gamma=gamma,ncomm=ncomm,nloc=nloc)
vmat=tmp$vmat
theta=tmp$theta
# theta[theta>hi]=hi; theta[theta<lo]=lo
# theta=theta.true
phi=rdirichlet1(alpha=nks+psi,ncomm=ncomm,nspp=nspp)
# phi[phi>hi]=hi; phi[phi<lo]=lo
# phi=phi.true
#calculate loglikelihood
prob=theta%*%phi
prob[prob>hi]=hi; prob[prob<lo]=lo
#calculate log prior
vmat1=vmat[,-ncomm]
vmat1[vmat1>hi]=hi; vmat1[vmat1<lo]=lo
log.p.betas=sum(dbeta(vmat1,1,gamma,log=T))
log.p.phi=sum(log(ddirichlet(phi,rep(psi,nspp))))
print(c(log.p.betas,log.p.phi))
#store results
llk[i]=sum(y*log(prob))
log.prior[i]=log.p.betas+log.p.phi
theta.out[i,]=theta
phi.out[i,]=phi
vmat.out[i,]=vmat
}
phi
ddirichlet(phi,rep(psi,nspp)))
ddirichlet(phi,rep(psi,nspp))
phi[ncommun,]
phi[ncomm,]
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
library('MCMCpack')
set.seed(4)
#-----------------------------------------------------------
#*****Unstructured LDA*****
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data6.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
ncomm=10
gamma=0.1
ngibbs=1000
nburn=ngibbs/2
psi=0.01
res=LDA.abundance(y=y,ncomm=ncomm,gamma=gamma,
ngibbs=ngibbs,nburn=nburn,psi=psi)
str(res)
ind=which(res$llk==max(res$llk))
vmat=matrix(res$vmat[ind,],nrow(y),ncomm)
head(vmat)
phi=matrix(res$phi[ind,],ncomm,ncol(y))
ind=which(res$llk==max(res$llk))
vmat=matrix(res$vmat[ind,],nrow(y),ncomm)
phi=matrix(res$phi[ind,],ncomm,ncol(y))
#-----------------------------------------------------------
#*****LDA covariates*****
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#get covariates
xmat=data.matrix(read.csv('fake data cov4.csv',as.is=T))
ind=which(res$llk==max(res$llk))
vmat=matrix(res$vmat[ind,],nrow(y),ncomm)
vmat1=vmat[,-ncomm]
phi=matrix(res$phi[ind,],ncomm,ncol(y))
tmp=log(vmat1/(1-vmat1))
head(tmp)
range(tmp)
hist(tmp)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#get covariates
xmat=data.matrix(read.csv('fake data cov4.csv',as.is=T))
#calculate implied betas
tmp=log(vmat1/(1-vmat1))
tmp[tmp < -10]=-10
tmp[tmp > 10]=10
p1=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp
betas
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp
betas
dim(betas)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#get covariates
xmat=data.matrix(read.csv('fake data cov4.csv',as.is=T))
#calculate implied betas
tmp=log(vmat1/(1-vmat1))
tmp[tmp < -10]=-10
tmp[tmp > 10]=10
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp
#run gibbs sampler
ncomm=10
ngibbs=1000
nburnin=ngibbs/2
res=LDA.MS.gibbs(y=y,xmat=xmat,ncomm=ncomm,ngibbs=ngibbs,nburnin=nburnin,
betas.init=betas,phi.init=phi)
res=LDA.MS.gibbs(y=y,xmat=xmat,ncomm=ncomm,ngibbs=ngibbs,nburnin=nburnin)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#get covariates
xmat=data.matrix(read.csv('fake data cov4.csv',as.is=T))
#calculate implied betas
tmp=log(vmat1/(1-vmat1))
tmp[tmp < -10]=-10
tmp[tmp > 10]=10
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp
#run gibbs sampler
ncomm=10
ngibbs=1000
nburnin=ngibbs/2
res=LDA.MS.gibbs(y=y,xmat=xmat,ncomm=ncomm,ngibbs=ngibbs,nburnin=nburnin,
betas.init=betas,phi.init=phi)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#get covariates
xmat=data.matrix(read.csv('fake data cov4.csv',as.is=T))
#run gibbs sampler
ncomm=10
ngibbs=1000
nburnin=ngibbs/2
res=LDA.MS.gibbs(y=y,xmat=xmat,ncomm=ncomm,ngibbs=ngibbs,nburnin=nburnin,
vmat.init=vmat1,phi.init=phi)
