for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
llk.ind.out=matrix(NA,ngibbs,nloc)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#sample lambda
lambda=get.lambda(nlk=nlk,a.gamma=a.gamma,b.gamma=b.gamma,
xmat=xmat,betas=betas,ncomm=ncomm)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=sqrt(var.betas),log=T)
#get lambda prior
p5=dgamma(lambda,a.gamma,b.gamma,log=T)
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)+sum(p5)
llk.ind.out[i,]=p2 #PAREI AQUI
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
llk.ind.out=matrix(NA,ngibbs,nloc)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#sample lambda
lambda=get.lambda(nlk=nlk,a.gamma=a.gamma,b.gamma=b.gamma,
xmat=xmat,betas=betas,ncomm=ncomm)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=sqrt(var.betas),log=T)
#get lambda prior
p5=dgamma(lambda,a.gamma,b.gamma,log=T)
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)+sum(p5)
llk.ind.out[i,]=p2 #PAREI AQUI
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
dim(array.lsk.init)
setwd('U:\\GIT_models\\LdaPoisson_nocov')
source('LdaPoisson_nocov main function.R')
source('LdaPoisson_nocov aux functions.R')
sourceCpp('LdaPoisson_nocov_aux_cpp.cpp')
res=gibbs.LDA.nocov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,
phi.prior=phi.prior,a.gamma=a.gamma,b.gamma=b.gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
llk.ind.out=matrix(NA,ngibbs,nloc)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#sample lambda
lambda=get.lambda(nlk=nlk,a.gamma=a.gamma,b.gamma=b.gamma,
xmat=xmat,betas=betas,ncomm=ncomm)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=sqrt(var.betas),log=T)
#get lambda prior
p5=dgamma(lambda,a.gamma,b.gamma,log=T)
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)+sum(p5)
llk.ind.out[i,]=p2 #PAREI AQUI
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
dim(p2)
length(p2)
p2
LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
dim(array.lsk.init)
array.lsk.init[1,,]
array.lsk.init[10,,]
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
#basic settings
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
llk.ind.out=matrix(NA,ngibbs,nloc)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#sample lambda
lambda=get.lambda(nlk=nlk,a.gamma=a.gamma,b.gamma=b.gamma,
xmat=xmat,betas=betas,ncomm=ncomm)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=sqrt(var.betas),log=T)
#get lambda prior
p5=dgamma(lambda,a.gamma,b.gamma,log=T)
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)+sum(p5)
llk.ind.out[i,]=p2
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
p2
#basic settings
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
llk.ind.out=matrix(NA,ngibbs,nloc)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
#sample phi
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
#sample lambda
lambda=get.lambda(nlk=nlk,a.gamma=a.gamma,b.gamma=b.gamma,
xmat=xmat,betas=betas,ncomm=ncomm)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=sqrt(var.betas),log=T)
#get lambda prior
p5=dgamma(lambda,a.gamma,b.gamma,log=T)
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)+sum(p5)
llk.ind.out[i,]=p2
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
head(llk.ind.out)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov and LDA no cov.R')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=10
ngibbs=1000
nburn=ngibbs/2
#priors
phi.prior=0.01
a.gamma=b.gamma=0.1
var.betas=10
#run Gibbs sampler
res=LDAcov(y=y,xmat=xmat,ncomm=ncomm,
phi.prior=phi.prior,a.gamma=a.gamma,b.gamma=b.gamma,
ngibbs=ngibbs,nburn=nburn,var.betas=var.betas)
head(res)
str(res)
plot(res$llk,type='l')
res$llk
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov and LDA no cov.R')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=10
ngibbs=1000
nburn=ngibbs/2
#priors
phi.prior=0.01
a.gamma=b.gamma=0.1
var.betas=10
#get functions
setwd('U:\\GIT_models\\LdaPoisson_nocov')
source('LdaPoisson_nocov main function.R')
source('LdaPoisson_nocov aux functions.R')
sourceCpp('LdaPoisson_nocov_aux_cpp.cpp')
res=gibbs.LDA.nocov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,
phi.prior=phi.prior,a.gamma=a.gamma,b.gamma=b.gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#----------------------------------------
#LDA with covariates
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
