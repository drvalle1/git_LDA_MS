pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
head(exp(lp1))
apply(exp(lp1),1,sum)
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
b.gamma=0
range(pmedia)
z=pmedia/matrix(pmedia.soma,nloc,ncomm,byrow=T)
apply(z,2,sum)
b.gamma
range(apply(z,2,sum))
sum(pmedia[,1]/sum(pmedia[,1]))
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)
sum(pmedia[,1]/pmedia.soma[1])
sum(pmedia[,2]/pmedia.soma[2])
sum(pmedia[,3]/pmedia.soma[3])
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior)
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
ordem=1:8
#look at lambda
compare1(estim=res$lambda[ngibbs,ordem],true=lambda.true)
#look at nlk
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm); tmp[495,]
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior)
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
ordem=1:8
#look at lambda
compare1(estim=res$lambda[ngibbs,ordem],true=lambda.true)
k=matrix(res$betas[ngibbs,],nparam,ncomm)
compare1(estim=k[,ordem],true=betas.true)
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior)
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
compare1(estim=res$lambda[ngibbs,ordem],true=lambda.true)
ordem=1:8
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm); tmp[495,]
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
k=matrix(res$betas[ngibbs,],nparam,ncomm)
compare1(estim=k[,ordem],true=betas.true)
sample.betas
rm(list=ls(all=TRUE))
library(MCMCpack)
set.seed(5)
nloc=500
nspp=20
ncommun=8
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-1,max=1),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
for (i in 1:10){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
image(xmat[1:(10*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=2,max=4)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
#generate phi (assuming that each species is strongly present in a single group)
phi=rdirichlet(ncommun,alpha=rep(0.1,nspp))
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[,i],type='h')
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_MS')
nome=paste('fake data',ncommun,'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
write.csv(y,nome,row.names=F)
nome=paste('fake data xmat',ncommun,'.csv',sep='')
write.csv(xmat,nome,row.names=F)
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior)
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
#basic settings
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
betas=matrix(0,nparam,ncomm)
array.lsk=array(0,dim=c(nloc,nspp,ncomm))
for (i in 1:nloc){
for (j in 1:nspp){
if (y[i,j]!=0){
array.lsk[i,j,]=rmultinom(1,size=y[i,j],prob=rep(1/ncomm,ncomm))
}
}
}
#basic test
# z=apply(array.lsk,1:2,sum)
# unique(y-z)
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
phi=matrix(1/nspp,ncomm,nspp)
lambda=apply(nlk,2,mean)
#get thetas
theta=get.theta.from.lambda(lambda=lambda,ncomm=ncomm)
#just checking
# teste=GetLambda(LogTheta=log(theta),ncomm=ncomm)
#priors
a.gamma=b.gamma=0.1
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#order communities according to size
# if (i<nburn & i%%50==0){
#   ind=order(lambda,decreasing=T)
#   lambda=lambda[ind]
#   theta=get.theta.from.lambda(lambda=lambda,ncomm=ncomm)
#
#   betas=betas[,ind]
#   phi=phi[ind,]
#   array.lsk=array.lsk[,,ind]
#   nlk=nlk[,ind]
# }
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
# array.lsk=array.lsk.true
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
# nks=nks.true#rbind(nks.true,0,0)
# nlk=nlk.true#cbind(nlk.true,0,0)
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump1=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
# betas=betas.true#cbind(betas.true,0,0)
#sample thetas
# theta=sample.theta(theta=theta,a1=a1,b1=b1,a2=a2,b2=b2,nlk=nlk,ncomm=ncomm,nloc=nloc,
#                    xmat=xmat,betas=betas)
# lambda=GetLambda(LogTheta=log(theta),ncomm=ncomm)
lambda=lambda.true#c(lambda.true,0.01,0.01)
#sample phi
# phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
# phi=phi.true #rbind(phi.true,0,0)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=1,log=T)
#get lambda prior
# p5=dgamma(theta[1],a1,b1,log=T)+sum(dgamma(theta[-1],a2,b2,log=T))
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)#+p5
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
jump1
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('gibbs sampler main function.R')
source('gibbs functions.R')
sourceCpp('aux1.cpp')
#get data
dat=read.csv('fake data8.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat8.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=8
ngibbs=1001
nburn=ngibbs/2
phi.prior=0.01
#basic settings
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
betas=matrix(0,nparam,ncomm)
array.lsk=array(0,dim=c(nloc,nspp,ncomm))
for (i in 1:nloc){
for (j in 1:nspp){
if (y[i,j]!=0){
array.lsk[i,j,]=rmultinom(1,size=y[i,j],prob=rep(1/ncomm,ncomm))
}
}
}
#basic test
# z=apply(array.lsk,1:2,sum)
# unique(y-z)
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
phi=matrix(1/nspp,ncomm,nspp)
lambda=apply(nlk,2,mean)
#get thetas
theta=get.theta.from.lambda(lambda=lambda,ncomm=ncomm)
#just checking
# teste=GetLambda(LogTheta=log(theta),ncomm=ncomm)
#priors
a.gamma=b.gamma=0.1
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#order communities according to size
# if (i<nburn & i%%50==0){
#   ind=order(lambda,decreasing=T)
#   lambda=lambda[ind]
#   theta=get.theta.from.lambda(lambda=lambda,ncomm=ncomm)
#
#   betas=betas[,ind]
#   phi=phi[ind,]
#   array.lsk=array.lsk[,,ind]
#   nlk=nlk[,ind]
# }
#get log of part 1
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
# array.lsk=array.lsk.true
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
# nks=nks.true#rbind(nks.true,0,0)
# nlk=nlk.true#cbind(nlk.true,0,0)
#sample betas
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump1=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
# betas=betas.true#cbind(betas.true,0,0)
#sample thetas
# theta=sample.theta(theta=theta,a1=a1,b1=b1,a2=a2,b2=b2,nlk=nlk,ncomm=ncomm,nloc=nloc,
#                    xmat=xmat,betas=betas)
# lambda=GetLambda(LogTheta=log(theta),ncomm=ncomm)
lambda=lambda.true#c(lambda.true,0.01,0.01)
#sample phi
# phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
# phi=phi.true #rbind(phi.true,0,0)
#adaptive MH
if (i%%accept.output==0 & i<nadapt){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#calculate Poisson probabilities
media=matrix(lambda,nloc,ncomm,byrow=T)*exp(xmat%*%betas)
p1=dpois(nlk,media,log=T)
# phi.tmp=phi; phi.tmp[phi.tmp<0.00001]=0.00001
p2=LogLikMultin(nloc=nloc,ncomm=ncomm,nspp=nspp,phi=phi,Arraylsk=array.lsk)
#get phi prior
p3=ldirichlet(x=phi,alpha=phi.prior)
# log(ddirichlet(phi[2,],rep(phi.prior,nspp)))
#get betas prior
p4=dnorm(betas,mean=0,sd=1,log=T)
#get lambda prior
# p5=dgamma(theta[1],a1,b1,log=T)+sum(dgamma(theta[-1],a2,b2,log=T))
#store results
llk.out[i]=sum(p1)+sum(p2)+sum(p3)+sum(p4)#+p5
phi.out[i,]=phi
lambda.out[i,]=lambda
nlk.out[i,]=nlk
betas.out[i,]=betas
}
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
plot(res$betas[,1],type='l')
plot(res$betas[,1],type='l')
cor(xmat)
