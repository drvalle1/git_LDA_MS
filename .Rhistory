plot(x,y,ylim=c(-8,5))
lines(x,b0+b1*x)
b0=-5
b1=1
y=rnorm(100,mean=b0+b1*x)
points(x,y,col='red')
b0=2
b1=-1
mig.time=seq(from=-2,to=2,length.out=100)
mean1=exp(b0+b1*mig.time)
plot(mig.time,mean1,type='l')
abline(v=-1.5,col='red')
lines(c(-2,-1.5),rep(32,2),col='blue')
#https://www.usgs.gov/centers/eros/science/usgs-eros-archive-landsat-archives-landsat-8-oli-operational-land-imager-and?qt-science_center_objects=0#qt-science_center_objects
ns.km=170 #north south
ew.km=183 #east west
m2=(ns.km*1000)*(183*1000)
pixel=30*30
#number of pixels
m2/pixel
niter=1000
sd.jump=0.1
a1=-1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=-1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=-1
a1.store=rep(NA,niter)
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1.store
}
warnings()
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(density(a1.store),type='l')
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=1
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new)
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
plot(density(a1.store),type='l')
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=2
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new) #reflect proposal if negative
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
rm(list=ls(all=TRUE))
set.seed(1)
#simulated data
nobs=100
a1=1
a2=2
x=rbeta(nobs,a1,a2)
log.target=function(a1,a2,x){
sum(dbeta(x,a1,a2,log=T))+dgamma(a1,0.5,0.5,log=T)+dgamma(a2,0.5,0.5,log=T)
}
#MH
niter=1000
sd.jump=0.0001
a1=0.1
a1.store=rep(NA,niter)
for (i in 1:niter){
a1.new=rnorm(1,mean=a1,sd=sd.jump)
a1.new=ifelse(a1.new<0,abs(a1.new),a1.new) #reflect proposal if negative
target.new=log.target(a1=a1.new,a2=a2,x=x)
target.old=log.target(a1=a1    ,a2=a2,x=x)
pthresh=exp(target.new-target.old)
if (runif(1)<pthresh) a1=a1.new
a1.store[i]=a1
}
plot(a1.store,type='l')
library(circular)
?dvonmises
data1 <- rvonmises(1000, circular(0), 10, control.circular=list(units="degrees"))
plot(data1)
ff <- function(x) dvonmises(x, mu=circular(pi), kappa=10)
curve.circular(ff, join=TRUE, xlim=c(-2.3, 1),
main="Density of a VonMises Distribution \n mu=pi, kappa=10")
x=seq(from=0,to=2*pi,length.out=1000)
y=dvonmises(x, mu=circular(pi), kappa=10)
plot(x,y)
x=seq(from=0,to=2*pi,length.out=1000)
y=dvonmises(x, mu=circular(2*pi*0.99), kappa=10)
plot(x,y)
plot(res$NBN,type='l')
?rnbinom
nobs=10000
n=3
mu=10
x=rnbinom(nobs,mu=mu,size=n)
p=n/(mu+n)
mean(x); mu
var(x); n*(1-p)/(p^2)
n=3
mu=10
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=3
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=25
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
p
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.1
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.01
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
n=0.01
mu=100
x=rnbinom(nobs,mu=mu,size=n)
x=x[x!=0]
p=n/(mu+n)
mean(x);
denom=(1-(p^n))
(1/denom)*mu
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(33)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
dim(y)
head(y)
hist(apply(y,1,sum))
mean(y==0)
head(xmat)
apply(xmat==1,2,mean)
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_abundance')
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(33)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm.init=10
ngibbs=1000
nburn=ngibbs/2
#priors
psi=0.01
gamma=0.1
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm.init,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
nlk=apply(array.lsk.init,c(1,3),sum)
theta=nlk/apply(nlk,1,sum)
par(mfrow=c(1,1),mar=c(3,3,1,1))
boxplot(theta)
ncomm=3
prop=apply(theta>0.99,2,sum,na.rm=T) #see which communities are never above 0.8
which(prop!=0)
cond=prop!=0
ncomm=sum(cond)
plot(res$llk,type='l')
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(33)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm.init=10
ngibbs=1000
nburn=ngibbs/2
#priors
psi=0.01
gamma=0.5
#----------------------------------------------------------
#run LDA no covariates to get initial values
#get functions
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
res=LDA.abundance(y=y,ncomm=ncomm.init,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#look at convergence
plot(res$llk,type='l')
dim(y)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=res$array.lsk
#look at convergence
plot(res$llk,type='l')
#determine optimal number of groups
nlk=apply(array.lsk.init,c(1,3),sum)
theta=nlk/apply(nlk,1,sum)
par(mfrow=c(1,1),mar=c(3,3,1,1))
boxplot(theta)
ncomm=3
prop=apply(theta>0.99,2,sum,na.rm=T) #see which communities are never above 0.8
prop
array.lsk=array.lsk.init[,,ind]
for (i in 1:nloc){
for (j in 1:nspp){
tmp=array.lsk.init[i,j,-ind]
n=sum(tmp)
if (n>0){
z=rmultinom(1,size=n,prob=rep(1/ncomm,ncomm))
array.lsk[i,j,]=array.lsk[i,j,]+z
}
}
}
ncomm=3
ind=1:ncomm
prop=apply(theta>0.99,2,sum,na.rm=T) #see which communities are never above 0.8
which(prop!=0)
# cond=prop!=0
# ncomm=sum(cond)
#re-distribute individuals within array.lsk.init that are in eliminated communities
array.lsk=array.lsk.init[,,ind]
for (i in 1:nloc){
for (j in 1:nspp){
tmp=array.lsk.init[i,j,-ind]
n=sum(tmp)
if (n>0){
z=rmultinom(1,size=n,prob=rep(1/ncomm,ncomm))
array.lsk[i,j,]=array.lsk[i,j,]+z
}
}
}
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat1=matrix(array.lsk,nloc*nspp*ncomm,1)
write.csv(dat1,'array lsk.csv',row.names=F)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
set.seed(10)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
y=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
nloc=nrow(y)
nspp=ncol(y)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
set.seed(10)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
nloc=nrow(y)
nspp=ncol(y)
tmp=read.csv('array lsk.csv',as.is=T)
ncomm=length(tmp$V1)/(nspp*nloc); ncomm
array.lsk.init=array(tmp$V1,dim=c(nloc,nspp,ncomm))
ngibbs=1000
nburn=ngibbs/2
#priors
phi.prior=0.01
var.betas=c(10,rep(10,ncol(xmat)-1))
gamma=0.1
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
sourceCpp('slice_betas.cpp')
sourceCpp('slice_NBN.cpp')
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
set.seed(10)
#get data
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS\\order dados')
dat=read.csv('y.csv',as.is=T)
xmat=data.matrix(read.csv('xmat.csv',as.is=T))
y=data.matrix(dat)
nloc=nrow(y)
nspp=ncol(y)
#get array.lsk
tmp=read.csv('array lsk.csv',as.is=T)
ncomm=length(tmp$V1)/(nspp*nloc); ncomm
array.lsk.init=array(tmp$V1,dim=c(nloc,nspp,ncomm))
#basic settings
ngibbs=1000
nburn=ngibbs/2
#priors
phi.prior=0.01
var.betas=c(10,rep(10,ncol(xmat)-1))
gamma=0.1
#----------------------------------------------------------
#LDA with covariates
#get functions
setwd('Z:\\Users\\drvalle\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
sourceCpp('slice_betas.cpp')
sourceCpp('slice_NBN.cpp')
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
var.betas=var.betas)
plot(res$llk,type='l')
plot(res$fmodel,type='l')
str(res)
