phi=matrix(res$phi[ngibbs,],ncomm,ncol(y))
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
nlk.init=matrix(res$nlk[ngibbs,],nrow(y),ncomm)
phi.init=matrix(res$phi[ngibbs,],ncomm,ncol(y))
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
phi=phi.init
nlk=nlk.init
array.lsk=array(0,dim=c(nloc,nspp,ncomm))
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=5
phi.prior=0.01
a.gamma=b.gamma=0.1
#----------------------------------------
#run LDA no covariates to get initial values
ngibbs=1000
nburn=ngibbs/2
#get functions
setwd('U:\\GIT_models\\LdaPoisson_nocov')
source('LdaPoisson_nocov main function.R')
source('LdaPoisson_nocov aux functions.R')
sourceCpp('LdaPoisson_nocov_aux_cpp.cpp')
res=gibbs.LDA.nocov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,
phi.prior=phi.prior,a.gamma=a.gamma,b.gamma=b.gamma)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=array(res$array.lsk[ngibbs,],dim=c(nloc,nspp,ncomm))
#basic settings
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
head(nlk)
head(xmat)
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=res$coef[1]
betas[,i]=res$coef[-1]
}
betas
nks=t(apply(array.lsk,2:3,sum))
head(nks)
dim(nks)
phi=nks/apply(nks,1,sum)
apply(phi,1,sum)
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=res$coef[1]
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
nparam=ncol(xmat)
nloc=nrow(y)
nspp=ncol(y)
#initial values
array.lsk=array.lsk.init
nlk=apply(array.lsk,c(1,3),sum)
betas=matrix(0,nparam,ncomm)
lambda=rep(0,ncomm)
for (i in 1:ncomm){
dat.tmp=cbind(nlk[,i],xmat)
colnames(dat.tmp)=c('y',paste0('cov',1:ncol(xmat)))
dat.tmp1=as.data.frame(dat.tmp)
res=glm(y~.,data=dat.tmp1,family='poisson')
lambda[i]=exp(res$coef[1])
betas[,i]=res$coef[-1]
}
nks=t(apply(array.lsk,2:3,sum))
phi=nks/apply(nks,1,sum); apply(phi,1,sum)
#to store outcomes from gibbs sampler
lambda.out=matrix(NA,ngibbs,ncomm)
phi.out=matrix(NA,ngibbs,nspp*ncomm)
nlk.out=matrix(NA,ngibbs,nloc*ncomm)
llk.out=rep(NA,ngibbs)
betas.out=matrix(NA,ngibbs,nparam*ncomm)
#useful stuff for MH algorithm
accept1=list(betas=matrix(0,nparam,ncomm))
jump1=list(betas=matrix(0.1,nparam,ncomm))
accept.output=50
nadapt=ngibbs/2
#run gibbs sampler
options(warn=2)
lpmedia=xmat%*%betas
pmedia=exp(lpmedia)
pmedia.soma=colSums(pmedia)+b.gamma
lp1=lpmedia-matrix(log(pmedia.soma),nloc,ncomm,byrow=T)
#get summaries of array.lsk
nk=colSums(nlk)
#sample z
tmp = SampleArray(Arraylsk=array.lsk, nloc=nloc,nspp=nspp,ncomm=ncomm,
y=y,lp1=lp1,runif1=runif(sum(y)),
nk=nk,nks=nks, PriorPhi=phi.prior, agamma=a.gamma)
array.lsk=tmp$ArrayLSK
nlk=apply(array.lsk,c(1,3),sum)
nks=t(apply(array.lsk,2:3,sum))
jump1=jump1$betas
jump1$betas
jump1=list(betas=matrix(0.1,nparam,ncomm))
jump=jump1$betas
jump=jump1$betas
betas.orig=betas.old=betas.prop=betas
betas.prop[]=rnorm(nparam*ncomm,mean=betas.old,sd=jump)
p2=a.gamma+colSums(nlk)
i=1
betas.new=betas.old
betas.new[i,]=betas.prop[i,]
lmedia.old=xmat%*%betas.old
lmedia.new=xmat%*%betas.new
p1.old=colSums(nlk*lmedia.old)
p1.new=colSums(nlk*lmedia.new)
media.old=exp(lmedia.old)
media.new=exp(lmedia.new)
p3.old=log(b.gamma+colSums(media.old))
p3.new=log(b.gamma+colSums(media.new))
betas.orig=betas.old=betas.prop=betas
betas.prop[]=rnorm(nparam*ncomm,mean=betas.old,sd=jump)
p2=a.gamma+colSums(nlk)
for (i in 1:nparam){
betas.new=betas.old
betas.new[i,]=betas.prop[i,]
lmedia.old=xmat%*%betas.old
lmedia.new=xmat%*%betas.new
p1.old=colSums(nlk*lmedia.old)
p1.new=colSums(nlk*lmedia.new)
media.old=exp(lmedia.old)
media.new=exp(lmedia.new)
p3.old=log(b.gamma+colSums(media.old))
p3.new=log(b.gamma+colSums(media.new))
prior.old=(1/2)*(betas.old[i,]^2)
prior.new=(1/2)*(betas.new[i,]^2)
pold=p1.old-p2*p3.old+prior.old
pnew=p1.new-p2*p3.new+prior.new
k=acceptMH(pold,pnew,betas.old[i,],betas.new[i,],F)
betas.old[i,]=k$x
}
betas.old!=betas.orig
pold
pnew
jump
jump=0.01
betas.orig=betas.old=betas.prop=betas
betas.prop[]=rnorm(nparam*ncomm,mean=betas.old,sd=jump)
p2=a.gamma+colSums(nlk)
for (i in 1:nparam){
betas.new=betas.old
betas.new[i,]=betas.prop[i,]
lmedia.old=xmat%*%betas.old
lmedia.new=xmat%*%betas.new
p1.old=colSums(nlk*lmedia.old)
p1.new=colSums(nlk*lmedia.new)
media.old=exp(lmedia.old)
media.new=exp(lmedia.new)
p3.old=log(b.gamma+colSums(media.old))
p3.new=log(b.gamma+colSums(media.new))
prior.old=(1/2)*(betas.old[i,]^2)
prior.new=(1/2)*(betas.new[i,]^2)
pold=p1.old-p2*p3.old+prior.old
pnew=p1.new-p2*p3.new+prior.new
k=acceptMH(pold,pnew,betas.old[i,],betas.new[i,],F)
betas.old[i,]=k$x
}
betas.old!=betas.orig
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
tmp=sample.betas(nlk=nlk,xmat=xmat,betas=betas,
ncomm=ncomm,nparam=nparam,jump=jump1$betas,
a.gamma=a.gamma,b.gamma=b.gamma)
str(tmp)
betas=tmp$betas
accept1$betas=accept1$betas+tmp$accept
phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
phi
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
a.gamma=a.gamma,b.gamma=b.gamma)
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
a.gamma=a.gamma,b.gamma=b.gamma)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
a.gamma=a.gamma,b.gamma=b.gamma)
plot(res$lambda[ngibbs,],type='h')
plot(res$llk,type='l')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
ordem=c(5,3,4,2,1)
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm);
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm);
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
library(MCMCpack)
set.seed(1)
nloc=1000
nspp=100
ncommun=5
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-1,max=1),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=3,max=5)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.6,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h')
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm);
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
k=matrix(res$betas[ngibbs,],nparam,ncomm)
compare1(estim=k[,ordem],true=betas.true)
tmp=matrix(res$phi[ngibbs,],ncomm,nspp)
tmp1=tmp[ordem,]
compare1(estim=tmp1,true=phi.true)
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
var.betas=10
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
rm(list=ls(all=TRUE))
library(MCMCpack)
library('Rcpp')
library('RcppArmadillo')
set.seed(10)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(read.csv('fake data xmat.csv',as.is=T))
y=data.matrix(dat)
#basic settings
ncomm=5
phi.prior=0.01
a.gamma=b.gamma=0.1
#----------------------------------------
#run LDA no covariates to get initial values
ngibbs=1000
nburn=ngibbs/2
#get functions
setwd('U:\\GIT_models\\LdaPoisson_nocov')
source('LdaPoisson_nocov main function.R')
source('LdaPoisson_nocov aux functions.R')
sourceCpp('LdaPoisson_nocov_aux_cpp.cpp')
res=gibbs.LDA.nocov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,
phi.prior=phi.prior,a.gamma=a.gamma,b.gamma=b.gamma)
nloc=nrow(y)
nspp=ncol(y)
array.lsk.init=array(res$array.lsk[ngibbs,],dim=c(nloc,nspp,ncomm))
#----------------------------------------
#LDA with covariates
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA cov main function.R')
source('LDA cov aux functions.R')
sourceCpp('LDA_cov_aux1_cpp.cpp')
var.betas=10
res=gibbs.LDA.cov(ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,y=y,xmat=xmat,
phi.prior=phi.prior,array.lsk.init=array.lsk.init,
a.gamma=a.gamma,b.gamma=b.gamma,var.betas=var.betas)
plot(res$llk[1:ngibbs],type='l')
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango)
}
k=res$lambda[ngibbs,]
plot(k,type='h')
k=res$betas[ngibbs,]
nparam=ncol(xmat)
k1=matrix(k,nparam,ncomm); round(k1,2)
ordem=c(5,3,4,2,1)
k1[,ordem]
round(k1[,ordem],3)
round(k1[,ordem],2)
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm);
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
library(MCMCpack)
set.seed(1)
nloc=1000
nspp=100
ncommun=5
#design matrix
xmat=matrix(runif(nloc*ncommun,min=-1,max=1),nloc,ncommun)
#pure sites
tmp=matrix(-3,ncommun,ncommun)
diag(tmp)=3
num1=floor(nloc/ncommun)
for (i in 1:120){
seq1=(ncommun*(i-1)+1):(ncommun*i)
xmat[seq1,]=tmp
}
image(xmat[1:(num1*ncommun),])
#parameters
lambda.true=lambda=runif(ncommun,min=3,max=5)
betas.true=betas=diag(1,ncommun)
#get means
lambda1=matrix(lambda,nloc,ncommun,byrow=T)
media.true=media=exp(log(lambda1)+xmat%*%betas); range(media)
head(media)
#generate N_lk
par(mfrow=c(1,1),mar=rep(4,4))
nlk=matrix(NA,nloc,ncommun)
for (i in 1:ncommun){
nlk[,i]=rpois(nloc,media[,i])
}
nlk.true=nlk; boxplot(nlk)
z=nlk/apply(nlk,1,sum); apply(z,1,sum); boxplot(z); apply(z,2,range); apply(z>0.6,2,mean)
nl=apply(nlk,1,sum)
hist(nl)
sum(nl)
plot(media,nlk)
#generate phi (assuming that each species is strongly present in a single group)
# x=0:4
# z=dbinom(x,size=4,prob=0.05)
# plot(x+1,z,type='h')
phi=matrix(0.01,ncommun,nspp)
num=floor(nspp/ncommun)
for (i in 1:nspp){
n=rbinom(1,size=1,prob=0.1)+1
ind=sample(1:ncommun,size=n)
phi[ind,i]=1
}
phi.true=phi=phi/matrix(apply(phi,1,sum),ncommun,nspp)
apply(phi,1,sum)
image(phi[,1:20])
#per species
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:(ncommun*2)) plot(phi[,i]/sum(phi[,i]),type='h')
par(mfrow=c(4,2),mar=rep(1,4))
for (i in 1:ncommun) plot(phi[i,],type='h')
# for (i in 1:nspp){ #add some zeroes
#   ind=sample(1:ncommun,size=1)
#   tmp[ind,i]=runif(1,min=0.5,max=1)
# }
# phi=tmp/matrix(rowSums(tmp),ncommun,nspp) #re-scale to make sure it sums to 1
# round(phi[,1:20],2)
# table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
image(phi)
#generate actual observations y
array.lsk=array(0,dim=c(nloc,nspp,ncommun))
for (i in 1:nloc){
for (k in 1:ncommun){
array.lsk[i,,k]=rmultinom(1,size=nlk[i,k],prob=phi[k,])
}
}
array.lsk.true=array.lsk
y=apply(array.lsk,c(1,2),sum)
nks=t(apply(array.lsk,c(2,3),sum))
image(y)
plot(phi,nks)
#checking if it makes sense
plot(apply(array.lsk,c(1,3),sum),nlk)
lines(c(0,1000),c(0,1000))
#look at stuff to make sure it makes sense
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp)
plot(phi.true,phi.estim)
nks.true=nks
tmp=matrix(res$nlk[ngibbs,],nloc,ncomm);
boxplot(tmp)
compare1(estim=jitter(tmp[,ordem]),true=jitter(nlk.true))
#look at betas
k=matrix(res$betas[ngibbs,],nparam,ncomm)
compare1(estim=k[,ordem],true=betas.true)
tmp=matrix(res$phi[ngibbs,],ncomm,nspp)
tmp1=tmp[ordem,]
compare1(estim=tmp1,true=phi.true)
