rownames(y)=paste('loc',1:nloc,sep='')
#look at convergence
plot(res$llk,type='l',ylim=range(res$llk,na.rm=T))
nloc=nrow(y)
theta=matrix(res$theta[nrow(res$theta),],nloc,ncomm)
boxplot(theta)
true.ncomm
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
rango=c(0,1)
for (i in 1:true.ncomm){
plot(theta.true[,i],theta1[,i],xlim=rango,ylim=rango,main=i)
lines(rango,rango,col='red',lwd=2)
}
theta=theta.init
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
nloc=nrow(xmat)
nparam=ncol(xmat)
tmp=res$betas[nrow(res$betas),]
betas=matrix(tmp,nparam,(ncomm-1))
#look at response curves
rango=apply(xmat.centered,2,range)
for (i in 2:nparam){
xmat1=matrix(0,nloc,nparam); xmat1[,1]=1
xmat1[,i]=seq(from=rango[1,i],to=rango[2,i],length.out=nloc)
media.true=xmat1%*%betas.true
media=xmat1%*%betas
vmat.t=cbind(pnorm(media.true),1)
theta.t=convertVtoTheta(vmat.t,rep(1,nloc))
vmat.e=cbind(pnorm(media),1)
theta.e=convertVtoTheta(vmat.e,rep(1,nloc))
par(mfrow=c(2,1))
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1),main=paste('true',i))
for (j in 1:ncol(theta.t)) lines(1:nloc,theta.t[,j],col=j)
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1),main=paste('estimated',i))
for (j in 1:ncol(theta.e)) lines(1:nloc,theta.e[,j],col=j)
par(mfrow=c(1,1))
ind=which(theta.t[800,]==max(theta.t[800,]))
plot(1:nloc,theta.t[,ind],main=i,type='l')
ind=which(theta.e[800,]==max(theta.e[800,]))
lines(1:nloc,theta.e[,ind],col='red')
}
nloc=nrow(y)
theta=matrix(res$theta[nrow(res$theta),],nloc,ncomm)
boxplot(theta)
dim(res$theta)
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
library('MCMCpack')
set.seed(4)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
xmat.centered=data.matrix(read.csv('fake data cov.csv',as.is=T))
#----------------------------------------------
#run standard LDA
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
ncomm=5
ngibbs=1000
nburn=ngibbs/2
psi=0.01
gamma=0.1
res=LDA.abundance(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
phi.init=matrix(res$phi[nrow(res$phi),],ncomm,ncol(y))
theta.init=matrix(res$theta[nrow(res$theta),],nrow(y),ncomm)
vmat.init=matrix(res$vmat[nrow(res$vmat),],nrow(y),ncomm)
boxplot(theta.init)
#Don't restrict the maximum number of groups according to theta.init because these are very different models.
#As a result, the "structured" LDA might have the need for a greater number of groups than what is suggested by the "unstructured" LDA
#-------------------------------------------------
#run "structured" LDA
#get functions
setwd('U:\\GIT_models\\git_LDA_MS')
source('LDA MS functions.R')
source('LDA MS gibbs sampler.R')
sourceCpp('LDA_MS_c.cpp')
#run gibbs sampler
ngibbs=10000
nburnin=ngibbs/2
phi.prior=psi
res=LDA.MS.gibbs(y=y,xmat=xmat.centered,ncomm=ncomm,ngibbs=ngibbs,nburnin=nburnin,phi.prior=phi.prior,
vmat.init1=vmat.init,phi.init=phi.init,
mu.betas=rep(0,ncol(xmat.centered)),
var.betas=rep(10,ncol(xmat.centered)))
library('Rcpp')
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('LDA_MS_c.cpp')
nloc=1000
nspp=200
ncommun=5
#generate covariates
dist=nloc/(ncommun+1)
init=1
xmat=matrix(rnorm(nloc*(ncommun-1)),nloc,ncommun-1)
xmat=cbind(2,xmat)
colnames(xmat)=paste('cov',0:(ncommun-1),sep='')
#look at xmat
plot(NA,NA,ylim=range(xmat),xlim=c(1,nloc),main='covariates')
for (i in 2:ncol(xmat)) lines(1:nloc,xmat[,i],col=i)
#standardize xmat
media1=apply(xmat,2,mean)
sd1=apply(xmat,2,sd)
xmat[,1]=1
for (i in 2:ncol(xmat)){
xmat[,i]=(xmat[,i]-media1[i])/sd1[i]
}
apply(xmat,2,mean)
apply(xmat,2,sd)
xmat.centered=xmat
#generate betas
betas=matrix(NA,ncol(xmat),ncommun-1)
betas[1,]=-1
betas[-1,]=diag(1,ncol(xmat)-1)
betas=betas*3
betas.true=betas
#generate thetas
vmat.true=vmat=cbind(pnorm(xmat.centered%*%betas.true),1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#this is important: it determines if the model will be able to disentagle these groups
boxplot(theta,ylim=c(0,1))
#create true curves
plot(NA,NA,ylim=c(0,1),xlim=c(0,nloc))
for (i in 1:ncommun){
lines(theta[,i],col=i)
}
apply(theta,2,max)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=400))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,nspp)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
#export results
setwd('U:\\GIT_models\\git_LDA_MS')
nome=paste(c('fake data','fake data cov'),'.csv',sep='')
colnames(y)=paste('spp',1:nspp,sep='')
rownames(y)=paste('loc',1:nloc,sep='')
plot(res$llk,type='l',ylim=range(res$llk,na.rm=T))
#look at theta
nloc=nrow(y)
theta=matrix(res$theta[nrow(res$theta),],nloc,ncomm)
boxplot(theta)
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
rango=c(0,1)
for (i in 1:true.ncomm){
plot(theta.true[,i],theta1[,i],xlim=rango,ylim=rango,main=i)
lines(rango,rango,col='red',lwd=2)
}
theta=theta.init
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
rango=c(0,1)
for (i in 1:true.ncomm){
plot(theta.true[,i],theta1[,i],xlim=rango,ylim=rango,main=i)
lines(rango,rango,col='red',lwd=2)
}
mu.betas=rep(0,ncol(xmat.centered))
var.betas=rep(10,ncol(xmat.centered))
#basic settings
nspp=ncol(y)
nloc=nrow(y)
npar=ncol(xmat)
nind.loc=apply(y,1,sum)
loc.expansion=rep(1:nloc,times=nind.loc)
#useful stuff
hi=0.999999
lo=0.000001
tx=t(xmat)
xtx=tx%*%xmat
phi=matrix(1/nspp,ncomm,nspp)
theta=matrix(1/ncomm,nloc,ncomm)
betas=matrix(0,npar,ncomm-1)
#initial values of parameters
if (!is.null(vmat.init1)) {
theta=convertVtoTheta(vmat.init1,rep(1,nloc))
#calculate implied betas
vmat.init2=vmat.init1[,-ncomm]
vmat.init2[vmat.init2>hi]=hi
vmat.init2[vmat.init2<lo]=lo
tmp=qnorm(vmat.init2)
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp #these should be good starting values
}
if (!is.null(phi.init))   phi=phi.init
#gibbs details
theta.out=matrix(NA,ngibbs,ncomm*nloc)
phi.out=matrix(NA,ngibbs,ncomm*nspp)
betas.out=matrix(NA,ngibbs,npar*(ncomm-1))
llk=rep(NA,ngibbs)
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample z
tmp=samplez(theta=theta, phi=phi, y=y, ncommun=ncomm, nloc=nloc, nspp=nspp)
nlk=tmp$nlk
# nlk=nlk.true
nks=tmp$nks
# nks=nks.true
#sample phi
# phi=rbind(phi.true,matrix(1/nspp,11,nspp))
phi=phi.true
# phi=rdirichlet1(alpha=nks+phi.prior,ncomm=ncomm,nspp=nspp)
# # phi[phi>hi]=hi; phi[phi<lo]=lo
# # phi[4,]=phi.true[4,]
#sample w
tmp=get.w(xmat=xmat,nlk=nlk,betas=betas,ncomm=ncomm,nloc=nloc)
soma=tmp$soma
n=tmp$n
#sample betas
tmp=get.betas(tx=tx,xmat=xmat,ncomm=ncomm,npar=npar,n=n,soma=soma,nloc=nloc,mu.betas=mu.betas,var.betas=var.betas)
betas=tmp$betas
theta=tmp$theta
#calculate loglikelihood
prob=theta%*%phi; prob[prob<lo]=lo #to avoid numerical issues
#store results
llk[i]=sum(y*log(prob))
theta.out[i,]=theta
phi.out[i,]=phi
betas.out[i,]=betas
}
dim(res$theta)
theta=matrix(res$theta[1000,],nloc,ncomm)
head(theta)
boxplot(theta)
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
theta=convertVtoTheta(vmat.init1,rep(1,nloc))
phi.init=matrix(res$phi[nrow(res$phi),],ncomm,ncol(y))
theta.init=matrix(res$theta[nrow(res$theta),],nrow(y),ncomm)
vmat.init=matrix(res$vmat[nrow(res$vmat),],nrow(y),ncomm)
rm(list=ls(all=TRUE))
library('mvtnorm')
library('Rcpp')
library('MCMCpack')
set.seed(4)
#get data
setwd('U:\\GIT_models\\git_LDA_MS')
dat=read.csv('fake data.csv',as.is=T)
ind=which(colnames(dat)=='X')
y=data.matrix(dat[,-ind]); dim(y)
xmat.centered=data.matrix(read.csv('fake data cov.csv',as.is=T))
#----------------------------------------------
#run standard LDA
#get functions
setwd('U:\\GIT_models\\git_LDA_abundance')
source('gibbs functions.R')
source('LDA.abundance main function.R')
sourceCpp('aux1.cpp')
ncomm=5
ngibbs=1000
nburn=ngibbs/2
psi=0.01
gamma=0.1
res=LDA.abundance(y=y,ncomm=ncomm,ngibbs=ngibbs,nburn=nburn,psi=psi,gamma=gamma)
str(res)
phi.init=matrix(res$phi[nrow(res$phi),],ncomm,ncol(y))
theta.init=matrix(res$theta[nrow(res$theta),],nrow(y),ncomm)
vmat.init=matrix(res$vmat[nrow(res$vmat),],nrow(y),ncomm)
vmat.init1=vmat.init
nspp=ncol(y)
nloc=nrow(y)
npar=ncol(xmat)
nind.loc=apply(y,1,sum)
loc.expansion=rep(1:nloc,times=nind.loc)
#useful stuff
hi=0.999999
lo=0.000001
tx=t(xmat)
xtx=tx%*%xmat
phi=matrix(1/nspp,ncomm,nspp)
theta=matrix(1/ncomm,nloc,ncomm)
betas=matrix(0,npar,ncomm-1)
xmat=xmat.centered
nspp=ncol(y)
nloc=nrow(y)
npar=ncol(xmat)
nind.loc=apply(y,1,sum)
loc.expansion=rep(1:nloc,times=nind.loc)
#useful stuff
hi=0.999999
lo=0.000001
tx=t(xmat)
xtx=tx%*%xmat
phi=matrix(1/nspp,ncomm,nspp)
theta=matrix(1/ncomm,nloc,ncomm)
betas=matrix(0,npar,ncomm-1)
theta=convertVtoTheta(vmat.init1,rep(1,nloc))
#calculate implied betas
vmat.init2=vmat.init1[,-ncomm]
vmat.init2[vmat.init2>hi]=hi
vmat.init2[vmat.init2<lo]=lo
tmp=qnorm(vmat.init2)
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp #these should be good starting values
betas
theta.true
library('Rcpp')
set.seed(4)
setwd('U:\\GIT_models\\git_LDA_MS')
sourceCpp('LDA_MS_c.cpp')
nloc=1000
nspp=200
ncommun=5
#generate covariates
dist=nloc/(ncommun+1)
init=1
xmat=matrix(rnorm(nloc*(ncommun-1)),nloc,ncommun-1)
xmat=cbind(2,xmat)
colnames(xmat)=paste('cov',0:(ncommun-1),sep='')
#look at xmat
plot(NA,NA,ylim=range(xmat),xlim=c(1,nloc),main='covariates')
for (i in 2:ncol(xmat)) lines(1:nloc,xmat[,i],col=i)
#standardize xmat
media1=apply(xmat,2,mean)
sd1=apply(xmat,2,sd)
xmat[,1]=1
for (i in 2:ncol(xmat)){
xmat[,i]=(xmat[,i]-media1[i])/sd1[i]
}
apply(xmat,2,mean)
apply(xmat,2,sd)
xmat.centered=xmat
#generate betas
betas=matrix(NA,ncol(xmat),ncommun-1)
betas[1,]=-1
betas[-1,]=diag(1,ncol(xmat)-1)
betas=betas*3
betas.true=betas
#generate thetas
vmat.true=vmat=cbind(pnorm(xmat.centered%*%betas.true),1)
theta.true=theta=convertVtoTheta(vmat,rep(1,nloc))
#this is important: it determines if the model will be able to disentagle these groups
boxplot(theta,ylim=c(0,1))
#create true curves
plot(NA,NA,ylim=c(0,1),xlim=c(0,nloc))
for (i in 1:ncommun){
lines(theta[,i],col=i)
}
apply(theta,2,max)
#generate phi
tmp=matrix(rnorm(ncommun*nspp,mean=0,sd=2),ncommun,nspp)
tmp[tmp<0.1]=0.1
tmp[,1:(2*ncommun)]=cbind(diag(8,ncommun),diag(8,ncommun))
phi=tmp/matrix(rowSums(tmp),ncommun,nspp)
round(phi[,1:20],2)
table(round(phi,2))
unique(rowSums(phi))
phi.true=phi
#generate actual observations y
nl=floor(runif(nloc,min=100,max=400))
nlk=matrix(NA,nloc,ncommun)
nks=matrix(0,ncommun,nspp)
y=matrix(NA,nloc,nspp)
for (i in 1:nloc){
nlk[i,]=rmultinom(1,size=nl[i],prob=theta[i,])
tmp1=rep(0,nspp)
for (k in 1:ncommun){
tmp=rmultinom(1,size=nlk[i,k],prob=phi[k,])
nks[k,]=nks[k,]+tmp
tmp1=tmp1+tmp
}
y[i,]=tmp1
}
image(y)
#look at stuff to make sure it makes sense
theta.estim=nlk/matrix(nl,nloc,ncommun)
plot(NA,NA,xlim=c(1,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta.estim[,i],col=i)
nlk.true=nlk
phi.estim=nks/matrix(rowSums(nks),ncommun,nspp,)
plot(phi.true,phi.estim)
nks.true=nks
vmat=matrix(NA,nloc,ncomm-1)
vmat[,1]=theta.true[,1]
vmat=matrix(NA,nloc,ncomm-1)
vmat[,1]=theta.true[,1]
tmp=1-theta.true[,1]
for (i in 2:(ncomm-1)){
vmat[,i]=theta.true[,i]/tmp
tmp=tmp*(1-theta.true[,i])
}
head(vmat)
vmat.init1=vmat
theta=convertVtoTheta(vmat.init1,rep(1,nloc))
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
vmat=matrix(NA,nloc,ncomm-1)
vmat[,1]=theta.true[,1]
tmp=1-theta.true[,1]
for (i in 2:(ncomm-1)){
vmat[,i]=theta.true[,i]/tmp
tmp=tmp*(1-theta.true[,i])
}
vmat=cbind(vmat,1)
vmat.init1=cbind(vmat,1)
vmat=matrix(NA,nloc,ncomm-1)
vmat[,1]=theta.true[,1]
tmp=1-theta.true[,1]
for (i in 2:(ncomm-1)){
vmat[,i]=theta.true[,i]/tmp
tmp=tmp*(1-theta.true[,i])
}
vmat.init1=cbind(vmat,1)
theta=convertVtoTheta(vmat.init1,rep(1,nloc))
true.ncomm=5
res1=matrix(NA,true.ncomm,ncomm)
for (i in 1:true.ncomm){
for (j in 1:ncomm){
res1[i,j]=cor(cbind(theta.true[,i],theta[,j]))[2,1]
}
}
ind=numeric()
for (i in 1:true.ncomm) ind=c(ind,which(res1[i,]==max(res1[i,])))
theta1=theta[,ind]
plot(theta.true,theta1)
vmat.init2=vmat.init1[,-ncomm]
vmat.init2[vmat.init2>hi]=hi
vmat.init2[vmat.init2<lo]=lo
tmp=qnorm(vmat.init2)
betas=solve(t(xmat)%*%xmat)%*%t(xmat)%*%tmp #these should be good starting values
betas
betas.true
plot(betas.true,betas)
